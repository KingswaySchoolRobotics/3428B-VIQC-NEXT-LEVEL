#pragma config(Sensor, port2,  ArmBottomBumper, sensorVexIQ_Touch)
#pragma config(Sensor, port3,  Main_Gyro,      sensorVexIQ_Gyro)
#pragma config(Sensor, port4,  LED,            sensorVexIQ_LED)
#pragma config(Sensor, port5,  ArmTopBumper,   sensorVexIQ_Touch)
#pragma config(Sensor, port7,  LeftColor,      sensorVexIQ_ColorGrayscale)
#pragma config(Sensor, port8,  MidColor,       sensorVexIQ_ColorGrayscale)
#pragma config(Sensor, port9,  RightColor,     sensorVexIQ_ColorGrayscale)
#pragma config(Motor,  motor1,          Left,          tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor6,          Right,         tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor10,         ArmRight,      tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor11,         ArmLeft,       tmotorVexIQ, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//E:/VIQC/NextLevelDrive.c
/*************************************PROGRAMMER NOTES*****************************************************//*
/*1*//* adjust position with tom and ben to use the double pusher Locking Mechanisim and presets /*DONE*/
/*2*//*arm motors bottom button reset /**DONE**/
/*3*//*remove touch led and ultrasonic with 2 motors at Front for latching once i get approval from the rest of the team /*DONE*/
/*4*//*
/*5*//*
/*6*//*
/*7*//*
/*8*//*
/*9*//*
/*10*//*
/*11*//*
/*12*//*
/*13*//*
/*14*//*
/*15*//*
*//*End of Notes Main Program Code is Below */


/*	Motor Diagnostics */
//bool overTemp; // if any of the motors are overtemp set this value to true
//bool currentLimitFlag; // if any of the motors are using current above the default value set this value to true
bool TurnDegrees (float varTurnDegrees) {
	if (varTurnDegrees>0) {
		setMotorSpeed(Left, 50);
		setMotorSpeed(Right, -50);
		if (getGyroDegrees(Main_Gyro)>varTurnDegrees) {
			return false;
		}
		} else {
		setMotorSpeed(Left, -50);
		setMotorSpeed(Right, 50);
		if (getGyroDegrees(Main_Gyro)<varTurnDegrees) {
			return false;

		}

	}
	return true;
}

void driveDistance(float distance, float DriveSpeed) {
	float MoveDistanceRotations=distance/200*360;
	moveMotorTarget(Left, MoveDistanceRotations, DriveSpeed);
	moveMotorTarget(Right, MoveDistanceRotations, DriveSpeed);
};

task main()
{

	resetMotorEncoder(ArmLeft);  //Resets Left Arm Motor Encoder to 0
	resetMotorEncoder(ArmRight); //Resets Right Arm Motor Encoder to 0

	while(true) {//while the program is running do this:
		resetGyro(Main_Gyro);
		while(TurnDegrees(-35)){};
		driveDistance(400, 60);
		delay(5000);
		setMotorTarget(ArmLeft,-680, 60);
		setMotorTarget(ArmRight,-680, 60);
		delay(3000);
		driveDistance(-400, 60);
		delay(5000);
		resetGyro(Main_Gyro);
		while(TurnDegrees(35)){};
		delay(5000);
		driveDistance(550, 60);
		delay(5000);
		setMotorTarget(ArmLeft,-680, 60);
		setMotorTarget(ArmRight,-680, 60);
		delay(1000);
		driveDistance(-100, 60);
		delay(1000);
		while(true) {
			setMotorSpeed(ArmLeft, 100);
			setMotorSpeed(ArmRight, 100);
		};
	};
}

//End of Program
